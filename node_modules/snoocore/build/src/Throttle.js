/*
   A basic throttle manager. Exposes 1 functoin `wait` that
   will return a promise that resolves once we've waited the proper
   amount of time, e.g.

   var throttle = new Throttle();

   throttle.wait() // resolves after 1ms
   throttle.wait() // resolves after 10001ms
   throttle.wait() // resolves after 2001ms

 */

'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _when = require('when');

var _when2 = _interopRequireDefault(_when);

var _whenDelay = require('when/delay');

var _whenDelay2 = _interopRequireDefault(_whenDelay);

var Throttle = (function () {
  function Throttle() {
    var throttleMs = arguments.length <= 0 || arguments[0] === undefined ? 1000 : arguments[0];

    _classCallCheck(this, Throttle);

    this._throttleMs = throttleMs;

    /*
       The current throttle delay before a request will go through
       increments every time a call is made, and is reduced when a
       call finishes.
        Time is added & removed based on the throttle variable.
     */
    this._throttleDelay = 1;
  }

  _createClass(Throttle, [{
    key: 'wait',
    value: function wait() {
      var _this = this;

      // resolve this promise after the current throttleDelay
      var delayPromise = (0, _whenDelay2['default'])(this._throttleDelay);

      // add throttleMs to the total throttleDelay
      this._throttleDelay += this._throttleMs;

      // after throttleMs time, subtract throttleMs from
      // the throttleDelay
      setTimeout(function () {
        _this._throttleDelay -= _this._throttleMs;
      }, this._throttleMs);

      return delayPromise;
    }

    /*
       Time in milliseconds to add to the throttle delay
    */
  }, {
    key: 'addTime',
    value: function addTime(timeMs) {
      this._throttleDelay += timeMs;
    }
  }]);

  return Throttle;
})();

exports['default'] = Throttle;
module.exports = exports['default'];
//# sourceMappingURL=Throttle.js.map
